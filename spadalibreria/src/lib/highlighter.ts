import { SearchOptions } from '@/types/search';

export interface MatchPosition {
  start: number;
  end: number;
  variant: string;
}

/**
 * Escapes special characters for regex
 */
function escapeRegExp(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Finds all occurrences of query and its variants in text
 * Respects search options (case, whole word, regex)
 */
export function findMatches(
  text: string, 
  query: string, 
  options: SearchOptions, 
  variants: string[] = []
): MatchPosition[] {
  if (!text || !query) return [];

  const matches: MatchPosition[] = [];
  const termsToSearch = [query, ...(options.includeVariants ? variants : [])];
  
  // Deduplicate terms
  const uniqueTerms = Array.from(new Set(termsToSearch));

  uniqueTerms.forEach(term => {
    if (!term) return;

    let pattern = '';
    let flags = 'g'; // Global search

    if (!options.matchCase) {
      flags += 'i'; // Case insensitive
    }

    if (options.useRegex) {
      // If regex mode, use the term as is (only for the main query usually, variants are literal)
      // But if variants are passed, they are usually literal words.
      // We should probably only treat the main query as regex if useRegex is true.
      // And variants should be treated as literals?
      // For simplicity, if useRegex is true, we assume the user knows what they are doing with the main query.
      // Variants are usually generated by the system as literals.
      
      if (term === query) {
        pattern = term;
      } else {
        // Variants are literals
        pattern = escapeRegExp(term);
      }
    } else {
      // Literal search
      pattern = escapeRegExp(term);
    }

    if (options.matchWholeWord) {
      pattern = `\\b${pattern}\\b`;
    }

    try {
      const regex = new RegExp(pattern, flags);
      let match;
      while ((match = regex.exec(text)) !== null) {
        matches.push({
          start: match.index,
          end: match.index + match[0].length,
          variant: term
        });
      }
    } catch {
      // Invalid regex, ignore
      console.warn('Invalid regex in search:', pattern);
    }
  });

  // Sort matches by start position and merge overlapping?
  // For highlighting, we need to handle overlaps.
  // But findMatches just returns all matches. The UI or a helper should handle overlaps.
  // Let's sort them at least.
  return matches.sort((a, b) => a.start - b.start);
}
